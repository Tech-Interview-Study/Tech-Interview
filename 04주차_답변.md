# 기술
## Statistics/Math 
- [p-value를 모르는 사람에게 설명한다면 어떻게 설명하실 건가요?](#1)
- [R square의 의미는 무엇인가요?](#2)
- [고유값(eigen value)와 고유벡터(eigen vector)에 대해 설명해주세요. 그리고 왜 중요할까요?](#3)

## Machine Learning 
- [앙상블 방법엔 어떤 것들이 있나요?](#4)
- [불균형 데이터를 어떻게 해결할 수 있을까요?](#5)
- [K-means의 대표적 의미론적 단점은 무엇인가요? (계산량 많다는것 말고)](#6)

## Deep Learning 
- [Adam Optimizer의 동작은?](#7)
- [딥러닝은 무엇인가요? 딥러닝과 머신러닝의 차이는?](#8)
- [Objective Function, Loss Function, Cost Function의 차이는 무엇인가요?](#9)

## Network
- [OSI 7계층을 설명하시오](#10)
- [TCP/IP의 각 계층을 설명해주세요.](#11)
- [OSI 7계층와 TCP/IP 계층의 차이를 설명해주세요.](#12)

## Database
- [데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요?](#13)
- [최소 신장 트리에 대해서 설명해 주세요.](#14)

## Operating System
- [뮤텍스와 세마포어의 차이를 설명해주세요.](#15)
- [교착상태(데드락, Deadlock)의 개념과 조건을 설명해주세요.](#16)

# 인성
- [어떤 개발자가 되고 싶으신가요?](#17)
- [평소 업무 스트레스를 어떻게 해결하시나요?](#18)
- [언제부터 개발에 관심을 가졌는가요?](#19)
- [프로젝트를 하면서 힘들었던 경험과 어떻게 해결했는지 말해주세요.](#20)
- [경쟁에서 져본 적이 있는지, 그때 배운 점이 있다면?](#21)
- [학점이 낮은 이유에 대해서 설명해주세요. or 학점이 다른 지원자에 비해서 높은데, 공부만 하셨나요?](#22)

---

</br>

## #1
### p-value를 모르는 사람에게 설명한다면 어떻게 설명하실 건가요?
- p-value는 실험결과가 우연적으로 발생한 것인지 그렇지 않은지 판단할 때 사용하는 수치입니다. 즉, p-value의 통계학적 정의는 **'귀무가설 하에서 관찰된 통계량만큼의 극단적인 값이 관찰될 확률'** 이고, p-value의 p는 probability입니다.

> - p-value는 가설검정을 할 때 쓰이는 기준이라고 할 수 있습니다. 가설검정은 기존의 주장인 귀무가설과 입증하고자 하는 가설인 대립가설을 설정하여 진행합니다. 이때 귀무가설이 참인데 기각한 경우를 1종 오류라고 하는데, 이러한 1종 오류를 범할 확률이 p-value입니다. 가설검정을 할 때에는 1종 오류를 범할 최대확률인 유의수준을 설정하여 유의 수준보다 p-value가 작다면 실험의 오류가 상한선보다 작으므로 귀무가설을 기각하고 입증하고자 하는 가설인 대립가설을 채택하게 됩니다.

</br>

## #2
### R square의 의미는 무엇인가요?

**회귀분석의 성능 평가 척도** 중 하나로, **결정력(결정계수)** 라고도 합니다. R-squared는 **독립변수가 종속변수를 얼마나 잘 설명하는 지**를 나타냅니다. R-squared는 0과 1 사이 값을 가집니다.  
MSE, RMSE, MAE의 경우 작을수록 좋지만 R-squared 는 클수록 좋습니다. 즉 **1에 가까울수록 독립변수가 종속변수를 잘 설명할 수 있다**는 뜻입니다.

> - $R^2=\frac{SSR}{SST} = 1-\frac{SSE}{SST}$
> - SST: 종속 변수의 총 변동성을 나타내는 제곱 합
> - SSR: 독립 변수들이 설명할 수 있는 종속 변수의 변동성
> - SSE: 회귀식 추정 y의 편차제곱의 합
> - R-squared는 독립변수의 설명력에 관계없이 독립변수가 많으면 많을수록 높아집니다. 이를 해결하기 위한 방법으로는 독립변수 개수에 대한 패널티를 부여하는 Adjusted R-squared (조정 설명계수)가 있습니다. 


</br>

## #3
### 고유값(eigen value)와 고유벡터(eigen vector)에 대해 설명해주세요. 그리고 왜 중요할까요?

**정방행렬인 A에 임의의 벡터 x를 곱한 값이 상수값인 λ(람다)에 임의의 벡터 x를 곱한 값과 같을 때**의 x를 고유 벡터, 람다를 고유값이라고 합니다.
기하하적인 입장에서 보면 **고유값 λ는 변화되는 크기**를 의미하며, **고유벡터 x는 변화되는 방향**을 의미하게 됩니다.
이러한 고유값과 고유벡터는 정방행렬을 분해하는 고유값 분해(EVD), 직사각행렬도 분해할 수 있는 특이값 분해(SVD), 데이터들을 차원 축소시킬 때 기존의 의미를 잘 보존시키는 **주성분 분석(PCA) 등에 활용**할 수 있어 중요하다고 할 수 있습니다.

> PCA는 Eigen value decomposition(고유값 분할)을 통해 새로 만든 '축(관점)'으로 데이터를 바라보는 것입니다. 데이터들의 평균으로 원점을 가정하고 고유값 분할을 통해서 공분산행렬, 고유값, 고유벡터를 구하게 됩니다. 이렇게 고유값 분할을 통해 얻게 된 새로운 다양한 축(고유벡터) 관점에서 가장 큰 분산을 가질 때의 축을 기준으로 데이터를 바라보게 됩니다.


</br>

## #4
### 앙상블 방법엔 어떤 것들이 있나요?

앙상블 방법엔 **voting, bagging, boosting, stacking**이 있습니다.  
**Voting**은 여러 개의 분류기가 투표를 통해 최종 예측 결과를 결정하는 방식으로 서로 다른 알고리즘을 여러 개 결합하여 사용합니다.  
**Bagging**은 각각의 데이터로 모델 여러개를 독립적으로 만들어서 각각 모델에서 예측값의 평균이나 최다투표값을 사용합니다.   
**Boosting**은 먼저 모델을 만들고, 그 모델이 약한 데이터에 대해서 새로운 모델(weak learner) 을 만든 후, weak learner를 합쳐서 strong learner를 만듭니다.  
이 외에 모델의 output을 새로운 독립변수로 사용하는 **stacking**이 있습니다.

> **앙상블(Ensemble)** 은 여러개의 모델을 조합해서 더 나은 예측 성능을 달성하는 머신러닝 기법입니다. 이러한 앙상블 방법에는 Voting, Bagging, Boosting, Stacking 등의 방법이 있습니다.  
**보팅(Voting)** 은 여러 개의 예측 모델을 결합하여 다수결 투표를 하는 방법입니다. 보팅을 사용하면 여러 모델이 조합되어 더 일반화된 성능을 보일 수 있습니다.  
**배깅(Bagging, Bootstrap Aggregation)** 이란 샘플을 여러번 뽑아(Bootstrap = 복원 랜덤 샘플링) **여러개의 독립적인 모델을 학습**시켜 각 모델의 예측 결과를 집계하는 **병렬적인** 방법입니다. 이때, 카테고리형 데이터는 투표 방식(Votinig)으로 결과를 집계하며, 연속형 데이터는 평균으로 집계합니다. Bagging을 사용한 대표적인 알고리즘으로는 랜덤 포레스트(Random Forest)가 있습니다. 이러한 배깅을 사용하게 되면, 학습 데이터가 충분하지 않더라도 충분한 학습효과를 주어 높은 bias의 underfitting 문제나, 높은 variance로 인한 overfitting 문제를 해결하는데 도움을 준다는 장점이 있습니다.  
**부스팅(Boosting)** 이란 이전 모델의 잘못 예측한 샘플에 가중치를 높여서 다음 모델을 학습하는 **순차적인** 방법입니다. 오답에 더 집중하여 학습시키기 떄문에 일반적으로 배깅에 비해 정확도가 높은 편이지만, 틀렸던 부분에 대해 반복적으로 학습하므로 오버피팅의 문제가 있으며, 이상치에 취약하고, 속도가 느리다는 단점이 있습니다. Boosting을 사용한 대표적인 알고리즘으로는 그래디언트 부스팅(Gradient Boosting)과 XGBoost, AdaBoost 가 있습니다.  
**스태킹(Stacking)** 이란 여러 개별 모델이 예측한 결과값을 다시 학습 데이터셋으로 사용해서 모델을 만드는 방법입니다. 그러나 같은 데이터셋을 통해 예측한 결과를 기반으로 다시 학습하게 되면 오버피팅 문제점이 있습니다. 따라서 이전 모델의 훈련 데이터에서 검증 데이터를 나누어 학습하는 Cross Validation 방식을 도입하여 이를 해결할 수 있습니다. 이를 통해, 첫 번째 단계에서 학습한 모델들이 하나의 검증 데이터에 대해 과적합되는 것을 방지하고, 더욱 일반화된 모델을 만들 수 있습니다.

</br>

## #5
### 불균형 데이터를 어떻게 해결할 수 있을까요?

불균형 데이터 상태 그대로 예측하게 된다면 **과적합 문제가 발생**할 수 있습니다. 모델은 가중치가 높은 클래스를 더 예측하려고 하기 때문에 accuracy는 높아질 수 있지만 분포가 작은 값에 대한 precision은 낮을 수 있고, 분포가 작은 클래스의 재현율이 낮아지는 문제가 발생할 수 있습니다. 이를 해결하기 위해 일반적으로 대표적으로 **Under Sampling과 Over Sampling**이 있습니다. 이 외에도 소수 클래스 데이터에 높은 가중치를 부여하는 방법, 소수 클래스 데이터를 기반으로 합성 데이터를 생성하여 데이터를 보강하는 방법이 있습니다.

> **Under Sampling**은 Down Sampling라고도 불리며 데이터의 분포가 높은 값을 낮은 값으로 맞춰주는 작업을 거치는 것을 말합니다. 데이터 분포를 확인 후 높은 class를 낮은 class크기에 맞춰주는 작업을 거치게 됩니다. 이런 과정을 거치면 유의미한 데이터만 남길 수 있지만 정보가 유실되는 문제가 생길 수 있습니다. 대표적인 방법으로는 Random Under Sampling, Tomek link, CNN 등이 있습니다.  
**Over sampling**은 Up Sampling라고도 불리며 분포가 작은 클래스의 값을 분포가 큰 클래스로 맞춰주는 샘플링 방법입니다. 분포가 작은 클래스 값을 일련의 과정을 거쳐 생성하는 방법을 뜻합니다. 이런 과정을 거치면 정보의 손실을 막을 수 있지만 여러 유형의 관측치를 다수 추가하기 때문에 오히려 오버피팅을 야기할 수 있습니다. (따라서 새로운 데이터, Test dataset에서의 성능이 나빠지는 결과를 초래할 수 있습니다.) 대표적인 방법으로는 Random Over Sampling, ADASYN(Adaptive Synthetic Sampling), SMOTE 등이 있습니다.

</br>

## #6
### K-means의 대표적 의미론적 단점은 무엇인가요? (계산량 많다는것 말고)

K-means clustering은 중심값 선정, 거리로 데이터 분류, 분류 완료까지 반복의 과정을 거치기 때문에 **중앙값 초기화를 잘못 할 경우 local minima에 빠질 위험**이 있습니다. 또한 모든 데이터를 거리로만 판단하기 때문에 사전에 주어진 목적이 없어 **결과 해석이 어렵다**는 단점이 있습니다. 노이즈가 많은 경우 효과적이지 않으며, 특히 하나의 군집이 큰 경우에는 해당 군집이 쪼개지면 비슷한 크기들의 클러스터로 형성될 수 있습니다. 데이터의 분포모양이 특이한 경우에도 군집이 잘 이루어지지 않습니다.


</br>

## #7
### Adam Optimizer의 동작은?

Momentum과 RMSProp를 합친 방식입니다. **Momentum** 방식과 같이 현재 기울기와 이전 기울기의 가중합을 이용하여 파라미터 업데이트를 수행하여 **기울기 방향을 조절**하고, **RMSProp**과 같이 기울기 제곱값의 이동 평균을 이용하여 **학습 속도를 조절**합니다. 따라서 기존의 최적화 알고리즘에 비해 더 빠르고 안정적으로 수렴할 수 있습니다. 오래전 time step에서의 값은 적게 반영하고 최근 step의 값을 많이 반영하기 위한 moving average를 하이퍼파라미터로 사용합니다. 

</br>

## #8
### 딥러닝은 무엇인가요? 딥러닝과 머신러닝의 차이는?

딥러닝은 머신러닝 알고리즘 중 하나인 **인공신경망(Artificial Neural Network, ANN)을 사용하는 모델**입니다. 머신러닝은 데이터의 특성을 사람이 직접 추출한 후 모델을 학습시키는 반면, 딥러닝은 **모델이 스스로 데이터의 특성을 추출하여 학습을 한다는 차이**가 있습니다.

</br>

## #9
### Objective Function, Loss Function, Cost Function의 차이는 무엇인가요?

Loss function은 하나의 input 데이터의 오차를 계산하는 함수입니다. Cost function은 이러한 Loss를 총 데이터에 대해 평균을 낸 값입니다. Objective function은 가장 일반화된 용어로 학습을 통해 최적화하려는 모든 종류의 함수를 의미합니다. 

> **Loss function ⊂ Cost Function ⊂ Objective Function**.  
> - 모델을 학습할 때는 비용(cost), 즉 오류를 최소화하는 방향으로 진행하게 됩니다. 비용이 최소화되는 곳이 성능이 잘 나오는 부분이며, 가능한 비용이 적은 부분을 찾는 것이 최적화 방법입니다. 이 비용 혹은 손실이 얼마나 있는지 나타내는 것이 비용함수, 손실함수라고 할 수 있습니다.
목적 함수는 매개변수를 최적화하는 함수입니다. 손실함수는 데이터 각각에 대해 학습한 매개 변수로 이루어지는 확률 함수 결과 확률 값과 실제 확률 값의 오차를 측정하는 함수입니다. 비용함수는 데이터 집합에 대한 오차 측정 함수입니다. 
즉, Objective Function가 가장 상위 개념이고 Cost Function과 Loss Function은 Object Function의 한 예라 볼 수 있습니다.


</br>

## #10
### OSI 7계층을 설명하시오
OSI 7 계층은 **네트워크에서 통신이 일어나는 과정을 7단계**로 나눈 것을 말합니다. 7계층으로 나눈 이유는 통신이 일어나는 과정을 단계별로 파악하기 위함과 **통신 과정 중에 특정한 곳에 이상이 생길 경우**에 다른 단계의 장비 및 소프트웨어 등을 건드리지 않고 **통신 장애를 일으킨 단계에서 해결할 수 있기 때문**입니다. 계층으로는 물리 계층, 데이터 링크 계층, 네트워크 계층, 전승 계층, 세션 계층, 표현 계층, 응용 프로그램 계층이 있습니다.

> OSI(Open Systems Interconnection Reference Model) 7계층이란, 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약입니다.  
**물리** 계층(physical layer)은 0과 1의 전기적 신호를 전송하는데 필요한 기능을 제공합니다. 장비로는 통신 케이블, 허브가 있습니다.  
데이터링크 계층(Data-Link Layer)은 프레임(Frame)이라는 단위로 MAC 주소를 가지고 같은 네트워크에 있는 컴퓨터들이 데이터를 주고받게 해주는 모듈입니다. 장비로는 브릿지, 스위치가 있습니다.  
네트워크 계층(Network Layer)은 목적지 컴퓨터로 데이터를 전송하기 위해 네트워크 간의 IP 주소를 통해 최적의 경로로 데이터 전달하는 라우팅 기능을 제공합니다. 장비로는 라우터, L3 스위치가 있습니다.  
\* IP : 각 컴퓨터들이 갖는 고유한 주소    
전송 계층(Transport Layer)은 데이터 전송을 위해서 Port 번호를 사용하여, 목적지 컴퓨터의 최종 도착지라고 할 수 있는 프로세스까지 데이터가 전송될 수 있게 하는 모듈입니다.  
세션 계층(Session Layer)은 통신 장치 간 상호작용과 동기화를 제공하여, 데이터 교환과 에러 발생 시 복구를 관리해주는 모듈입니다.  
표현 계층(Presentation Layer)은 세션 계층 간의 주고받는 인터페이스를 일관성있게 제공하는 역할을 합니다.  
애플리케이션 계층(Application Layer)은 사용자가 다른 컴퓨터 간의 통신을 가능하게 하며, 이를 위해 다양한 프로그램과 프로토콜을 사용합니다.

</br>

## #11
### TCP/IP의 각 계층을 설명해주세요.

TCP/IP 4계층은 애플리케이션 계층, 전송 계층, 인터넷 계층, 네트워크 접근 계층으로 이루어져있습니다. TCP/IP는 2개의 계층으로 구분됩니다. 메세지나 파일을 작은 패킷으로 나누거나 재조립하여 송수신에 반영하는 일을 담당하는 TCP(상위계층), 각 패킷의 주소 부분들을 처리하여 패킷들이 목적지로 정확히 송수신되도록 기능하는 IP(하위계층)으로 나눠집니다.  
하지만, 인터넷 개발 이후 꾸준히 표준이 갱신되면서 하위 레이어가 다시 세분화되었고, 오른쪽의 TCP/IP Updated 모델이 탄생했습니다. TCP/IP Updated의 5계층 모델은 Link를 다시 두 레이어로 세분화하고, Internet 명칭을 Network로 다시 변경했다는 차이가 있습니다.

</br>

## #12
### OSI 7계층와 TCP/IP 계층의 차이를 설명해주세요.

OSI와 TCP/IP는 **둘 다 네트워크 통신 모델의 표준**입니다.  
**OSI** 7계층은 네트워크 전송 시 데이터 표준을 정리한 개념적 모델로 통신에는 **실질적으로 사용되지 않습니다**.  
**TCP/IP는 OSI을 상업적이고 실무적으로 이용될 수 있도록 단순화**한 것이라고 할 수 있습니다. 따라서 현대의 인터넷은 TCP/IP 모델을 표준으로 따르고 있습니다.


</br>

## #13
### 데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요?  

**데이터베이스의 목적과 사용자 요구 사항을 잘 이해하고 이를 바탕으로 효율적이고 일관된 데이터 모델을 설계**하는 것입니다. 따라서 데이터베이스를 설계할 때는 어떤 데이터가 어떻게 사용되는지, 어떤 종류의 데이터가 필요한지, 어떤 연산이 자주 수행되는지 등을 고려해야 합니다.
또한 데이터베이스의 설계는 **데이터의 일관성, 무결성, 보안** 등을 보장해야 합니다. 이를 위해, **테이블 간의 관계**를 잘 설정하고, **적절한 제약 조건**을 설정하여 **데이터의 무결성**을 유지하고, 보안 측면에서도 **적절한 접근 권한 설정**을 고려해 주어야 합니다.
마지막으로 데이터베이스는 변화하는 요구 사항에 대응할 수 있도록 설계되어야 합니다. 이를 위해 유지보수 및 확장성을 고려하여 데이터베이스를 설계해야 합니다.

</br>

## #14
### 최소 신장 트리에 대해서 설명해 주세요.

신장트리는 **최소한의 간선으로 그래프 내의 모든 정점을 포함하도록 하는 트리**입니다. 최소 신장 트리란 spanning tree 중 간선의 **weight의 합이 최소가 되는 트리**를 말합니다. 사이클이 존재해서는 안되며 최단 경로를 보장하지 않는다는 특징이 있습니다. 통신망, 유통망 등 **길이, 구축 비용, 전송 시간 등을 최소로 구축하는 경우에 사용**할 수 있으며 **Kruskal 등의 알고리즘을 이용해 구현**할 수 있습니다.


</br>

## #15
### 뮤텍스와 세마포어의 차이를 설명해주세요.

뮤텍스와 세마포어의 가장 큰 차이점은 **동기화 대상의 개수**입니다. 뮤텍스는 동기화 대상이 1개일 때 사용하지만 세마포어는 동기화 대상이 1개 이상일 때 사용합니다. 세모포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없습니다. 뮤텍스는 자원 소유가 가능하지만 세마포어는 자원 소유가 불가합니다. 또한 뮤텍스는 소유하고 있는 스레드만이 뮤텍스를 해제할 수 있는 반면, 세마포어는 세마포어가 소유하지 않는 스레드가 세마포어를 해제할 수 있습니다.

> **뮤텍스**는 한 **쓰레드, 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제기법**입니다. Locking 메커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역(Critical Section)에 들어올 수 있습니다. 그리고 오직 이 쓰레드만이 임계 영역에서 나갈 때 뮤텍스를 해제할 수 있습니다.  
**세마포어**는  **현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성**하는 기법입니다. wait를 호출하면 세마포어의 카운트를 1줄이고, 세마포어의 카운트가 0보다 작거나 같아질 경우에 락이 실행됩니다. Signaling 메커니즘으로 락을 걸지 않은 쓰레드도 signal을 사용해 락을 해제할 수 있습니다. 세마포어의 카운트를 1로 설정하면 뮤텍스처럼 활용할 수 있습니다.

</br>

## #16
### 교착상태(데드락, Deadlock)의 개념과 조건을 설명해주세요.

데드락이란 **두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태로 무한히 다음 자원을 기다리게 되는 상태**를 말합니다.  
데드락은 상호 배제(mutual exclusion), 점유 대기(hold and wait), 비선점(no preemition), 순환 대기(circular wait)의 4조건을 모두 만족해야 성립합니다.

> 교착상태가 발생하는 4가지 조건이 있는데 한번에 오직 한개의 작업만 자원에 접근할 수 있는 **상호배제**, 프로세스가 할당된 자원을 가진 생타에서 다른 자원을 기다리는 **점유대기**, 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뻇을 수 없는 **비선점**, 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있는 **순환대기**가 있습니다. 이 조건 중에 한가지라도 만족하지 않으면, 교착상태는 발생하지 않습니다.
> 이중 순환대기 조건은 점유대기 조건과 비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아닙니다.


----
# 인성
## #17
### 어떤 개발자가 되고 싶으신가요?

- 동료와 함께 성장할 수 있는 개발자가 되고 싶습니다. 항상 새로운 기술이 끊임없이 나오는 ai 분야에서 뒤쳐지지 않기 위해서는 스스로의 노력뿐 아니라 동료와의 협업도 중요한 요소라고 생각합니다. 원활한 의사소통을 통해 새로 알게된 사실은 공유하고 잘못된 부분에는 망설이지 않고 피드백을 제공하며 소속된 팀에 공헌할 수 있는 개발자가 되고 싶습니다.

- 지속적으로 성장해 나가는 개발자가 되고 싶습니다. 개발 분야 중 특히 AI 분야는 새로운 기술들이 끊임없이 나오는 분야라고 생각합니다. 이러한 AI 분야에서 업무와 관련된 기술들을 빠르게 익히며, 지속적인 성장을 하고자 노력하는 개발자가 되고 싶습니다. 이를 위해 평소에 부족한 역량들을 기르고자 꾸준히 공부하며, 새로운 기술들을 익히고자 노력할 것 입니다.

- 저에 대한 확신이 있는 개발자가 되고 싶습니다. 새로운 기술이나 지식을 꾸준히 익히고 개발 실력을 늘려 저에게 확신 있는 개발자가 되고 싶습니다. 저에게 확신이 있을 때쯤이면 주니어가 훌륭한 엔지니어로 성장할 수 있게 도움이 주는 개발자가 될 것 같습니다.

</br>

## #18
### 평소 업무 스트레스를 어떻게 해결하시나요?

- 스트레스의 원인이 된 업무를 가장 먼저 처리할 것 같습니다. 스트레스가 생긴 업무를 외면하고 싶어 미루게되면 업무에 대한 스트레스만 더 커지고 다른 업무에도 지장을 받기 때문입니다. 업무시간 외엔 평소 취미인 운동과 춤 연습으로 스트레스를 풀것 같습니다.

- 업무에 대해 스트레스를 받게 되어도 일단은 하던 업무를 가능한 마무리하고자 할 것 같습니다. 그렇지만, 스트레스 때문에 업무에 대한 성과가 나오지 않을 것 같은 경우에는 잠시 업무와 관련이 없는 취미를 즐기면서 리프레쉬를 하고자 할 것 같습니다.

- 제가 스트레스를 받는 이유는 모르는 것에 대한 막연함, 두려움이 원인이 되는 것 같습니다. 그래서 만약 시간적 여유가 주어진다면, 천천히 업무에 대한 사전조사를 충분히 하고 해결책이 떠오르면 그 업무를 처리하는 것 같습니다.

</br>

## #19
### 언제부터 개발에 관심을 가졌는가요?

- 대학교 3학년 프로그래밍을 배우며 성공/실패가 명확하게 보이고, 오류를 해결해 프로그램이 성공적으로 돌아가는 것을 보며 개발에 관심을 가지게 됐습니다. 이후 실험 과목에서 C언어로 opencv 라이브러리를 직접 구현하며 제가 짠 코드의 결과물을 눈으로 확인할 수 있다는 점에서 컴퓨터비전에 흥미를 가지게 됐습니다. 

- 고등학교 2학년 때, 알파고와 이세돌의 대국이 있었는데, 이때 빅데이터에 대해 관심이 생기게 되었습니다. 그렇게 문과임에도 빅데이터를 다루는 직업을 희망하게 되면서 이과로 전향해서 빅데이터와 관련된 학과에 입학해 개발 공부를 하게 되었습니다.

- 개발에 관심을 가진 것은 4학년 인턴을 하면서 개발에 흥미를 가지게 되었습니다. 학교를 다니면서 개발에 대한 지식만 쌓다보니 현업에서는 어떻게 사용할 수 있는지에 대한 정보를 몰랐고, 이에 개발에 대한 관심은 있었지만 많은 흥미를 느끼지 못했습니다. 인턴십을 진행하면서 현업에 저의 코드를 적용해보았고 이를 통해서 개발에 흥미를 느낄 수 있었습니다. (+ 컴공을 가게된 이유)

</br>

## #20
### 프로젝트를 하면서 힘들었던 경험과 어떻게 해결했는지 말해주세요.

- 부스트캠프 내부 경진대회에 참가하며 컴퓨터비전 모델에 대한 이해가 부족해 어려움을 겪은 경험이 있습니다. AI 개발자는 기술에 대한 이론적 이해뿐만 아니라 코드를 다룰 줄 아는 실무적인 능력이 중요하다고 생각해 두 가지 방식으로 노력했습니다. 먼저 컴퓨터비전 모델에 대한 강의를 수강하며 모델의 동작 원리를 이해했습니다. 이후 github에서 모델을 구현한 코드에 주석을 한줄한줄 달아가며 모델 구조와 동작 방법을 익혔습니다. 이러한 노력을 통해 기존 모델을 용도에 맞게 변경하거나 간단한 모델을 직접 설계할 수 있었고, 경진대회를 무사히 마무리 할 수 있었습니다.

- 해외 교수님들과 연구를 진행하는 프로그램에서 pytorch로 이미지 처리를 하는 연구를 하게 맡게 된  경험이 있습니다. 이때 저는 pytorch라는 프레임워크와 이미지 처리 도메인 모두 처음이었습니다. 그래서 먼저 pytorch를 빠르게 익히고자 유튜브를 참고하여 기본 문법들을 공부하였습니다. 관련 기본지식이 부족했던 만큼, 다른 사람들보다 2배씩 노력해야겠다는 마음가짐으로 인터넷 서치를 통해 그때마다 필요한 문법들을 익히면서 연구를 진행하였습니다. 비록 전부 이해 하면서 코드를 작성하지는 못하였지만, 이러한 노력을 통해 처음 접하는 기술과 분야였음에도 무사히 연구를 마무리할 수 있었습니다.

- 저는 부스트캠프 프로젝트를 하면서 백엔드 개발을 처음 해보았습니다. 저는 백엔드에 대한 지식도 없을 뿐더라 기본 구조가 어떻게 되는지 어떻게 데이터가 흐르는지에 대해서도 알지 못했습니다. 이를 해결하기 위해 FastAPI에 대한 강의를 열심히 들었고 오픈 소스를 많이 찾아봄으로써 기본 구조가 어떻게 되는지 파악하였습니다. 이를 통해서 API를 하나씩 만들 수 있었고, 백엔드 개발을 통해 개발 전체으로 어떻게 데이터가 흐르고 서비스가 완성되는지 알 수 있었습니다.

</br>

## #21
### 경쟁에서 져본 적이 있는지, 그때 배운 점이 있다면?

- ai 모델 개발 경진대회에 참가해 중간까지 어느정도 성적을 거둔 후 '이정도면 충분히 한거겠지?'라는 마인드로 불성실하게 참여했더니 순위에서 밀려 입상하지 못한 경험이 있습니다. 이후 어떤 일이든 안일하게 생각하지 말고 끝까지 후회하지 않도록 최선을 다해 참가해야겠다라는 마인드를 갖게 됐습니다.

- 부스트캠프에서 첫 대회를 진행하면서 높지 않은 등수를 받았습니다. 처음 접한 대회인 만큼 빠른 시간안에 중요 포인트를 잡지 못해 시간을 허비했습니다. 이를 통해서 많은 시도를 하는 것은 좋으나 정확한 분석과 우선순위, 계획을 세우는 것이 중요하다는 것을 느꼈습니다.

</br>

## #22
### 학점이 낮은 이유에 대해서 설명해주세요. or 학점이 다른 지원자에 비해서 높은데, 공부만 하셨나요?

- 저는 대학생 초반에는 진로를 정하지 못하여 어떤 과목을, 왜 공부해야할지에 대한 이유를 찾지 못하고 있었습니다. 하지만 3학년에 들은 전공 수업을 통해 AI 개발자가 되자라는 구체적인 목표를 갖게 됐습니다. 이후 학과 수업 뿐만 아니라 부스트캠프에 참가해 전공 지식을 쌓고 경진대회에 참여해 실무 경험을 쌓는 방법으로 개발자의 역량을 기르기 위해 노력했습니다. 


-  첫 번째, 과거에 대한 쿨한 인정 -> 두 번째, 앞으로의 자세와 결심 <br>
저는 2학년 때 컴퓨터공학과로 전과를 했습니다. 이 당시 1학년 기초 과목을 듣지 않고 전과를 해 새로운 지식을 머리속에 집어 넣는 것에 급급했고, 초반에 과 친구를 사귀지 못해 중요한 정보를 못듣곤 했습니다. 이러한 이유로 2학년 당시 낮은 학점을 받게 되었고 이를 통해서 기초의 중요성을 깨닫게 되었습니다. 낮은 학점의 원인을 파악하고 3학년으로 올라기전 기초적인 전공 지식에 대한 공부를 하였고 이를 통해서 점점 학점을 올릴 수 있었습니다. 


- 학과에서 배우는 과목들이 제가 하고자 하는 업무에서의 기본 지식이라고 생각되어 전공 과목들을 제대로 이해하고자 하였었습니다. 특히, 저는 문과에서 이과로 전향했었기 때문에 학과 전공 수업들이 저의 기초 지식을 쌓는 데에 도움이 된다고 생각하여 더 열심히 공부하고자 했었습니다. 그렇지만 AI 개발 분야는 연구 역량과 협업 프로젝트를 통한 실무 역량이 필요하다고 생각되어, 학부 연구실과 개발 스터디 동아리 그리고 부스트 캠프를 통해 학과 전공 수업으로 배울 수 없는 개발자의 역량들을 기르고자 하였습니다.