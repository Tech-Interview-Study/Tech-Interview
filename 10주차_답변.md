# 기술

## Data Structure
- [트리의 탐색 복잡도?](#1)
- [그러한 탐색복잡도가 나오는 이유](#2)

## Deep Learning
- [backpropagation시 더하기, 곱하기, 활성화함수 등의 각 노드에서 어떻게 연산되는지?](#3)
- [zero-centered가 아닐 경우 무슨 문제가 발생하나요?](#4)

## Database
- [인덱스는 크게 Hash 인덱스와 B-Tree 인덱스가 있습니다. 이것은 무엇일까요?](#5)


## Python

- [파이썬에서 메모리는 어떻게 관리되나요?](#6)
- [힙(heap)이 동적할당을 구현하는데 사용되는 이유가 무엇인가요?](#7)
- [Garbage Collector(GC)가 무엇인가요?](#8)
- [JSON과 Dictionary의 차이는 무엇인가요?](#9)



# 인성
- [상사가 본인을 싫어한다면 어떻게 대처하실건가요?](#10)
- [리더의 역할은 무엇이라고 생각하나요?](#11)
- [회사 기술 스택에 맞추어 단기간 내에 언어와 프레임워크를 학습해야 할 때, 어떻게 공부하고 해결할 것인가요?](#12)
- [개발 프로세스에서 어떤게 제일 재미있었나?](#13)
- [상사와의 갈등을 어떻게 해결하시나요?(이미 나왔던 질문이지만 다시 답변 정리해보기 위함)](#14)
---

</br>

## #1
### 이진 트리의 시간 복잡도?

최악의 경우, 즉 편향된 이진 트리인 경우엔 시간 복잡도는 O(n)입니다.
그러나 잘 정렬된 이진 트리의 경우 트리높이에 비례하는 O(log n)의 복잡도를 가집니다.

</br>


## 2
### 이진 트리의 시간 복잡도가 O(logN)인 이유

이진 탐색 트리에서는 왼쪽 서브트리의 모든 노드 값이 현재 노드 값보다 작고, 오른쪽 서브트리의 모든 노드 값이 현재 노드 값보다 큰 특성을 가집니다. 이런 특성으로 인해 이진 탐색 트리에서의 탐색은 탐색 경로를 절반씩 제거하면서 진행할 수 있습니다. 따라서 이진 탐색 트리의 시간 복잡도는 O(log n)이 됩니다.  
그러나 편향된 이진트리의 경우에는 최악의 경우에 모든 노드를 탐색하게 됩니다. 따라서 최악의 경우에 O(n)의 시간복잡도가 나올 수 있습니다.


> 데이터 개수를 n, 트리의 높이를 d라고 할때, n = 2^d 이고, 이를 정리하면 d = log n 이 됩니다. 트리의 깊이가 곧 시간 복잡도이기에 시간 복잡도는 O(logN)이 됩니다. 


</br>

## #3
### backpropagation시 더하기, 곱하기, 활성화함수 등의 각 노드에서 어떻게 연산되는지?

Backpropagation은 연쇄법칙을 이용하여 upstream gradient에서 들어온 값에 local gradient값을 곱하여 그래디언트 계산을 합니다. 
덧셈일 경우 $z = x+y$의 미분은 $x$에 대해 미분해도 1, $y$에 대해 미분해도 1이기 떄문에 덧셈 노드의 역전파는 입력 값을 그대로 흘려보냅니다.
곱셈일 경우 $z = xy$의 미분은 $x$에 대해 미분하면 $y$, $y$에 대해 미분하면 $x$가 됩니다. 
그렇기에 forward에서의 입력값을 서로 바꾼 후, upstream gradient을 곱하여 계산됩니다. 
활성화 함수의 경우에는 
- relu에서는 음수일때는 0, 양수일때는 1의 미분값을 곱해주면 됩니다.
- sigmoid는 simoid결과값을 y라고 두면 y(1-y)이 미분값이기에 이를 곱하면 됩니다.
- tanh는 tanh결과값을 y라고 두면 1-y^2이 미분값이기에 이를 곱하면 됩니다.  

\* upstream gradient: 입력으로 받은 이전 gradient의 값  
\* local gradient: 현재 노드에서의 미분값

</br>

## #4
### zero-centered가 아닐 경우 무슨 문제가 발생하나요?

zero centered가 되지 않는 경우 결과값이 모두 양수를 가지게 되고, 이는 역전파시 모든 가중치의 그래디언트가 + 혹은 -로 되어 최적의 해를 곧바로 찾는 것이아니라 zig-zag형태로 움직이며 찾게 되어 비효율적입니다. 이러한 이유로 일반적으로 zero-mean data를 원하고 input x가 양수/음수를 모두 가지고 있으면 gradient w가 전부 Positive/Negative로 움직이는 것을 막을 수 있습니다.

> [zero-centered + gradient vanshing 문제]
> - 활성화 함수가 zero-centered가 아니면, 그래디언트가 양수 또는 음수 부분에 한쪽으로 치우쳐질 수 있습니다. 이러한 활성화 함수를 여러 레이어로 거치게 되면, 그래디언트가 소실이나 폭주와 같은 문제가 발생할 수 있습니다.
> [[모두를 위한 cs231n] Lecture 6. Activation Functions에 대해 알아보자](https://deepinsight.tistory.com/113)

</br>


## #5
### 인덱스는 크게 Hash 인덱스와 B-Tree 인덱스가 있습니다. 이것은 무엇일까요?
**B-Tree 인덱스**
- equal(=)뿐만 아니라 >, >=, <, <= 또는 between 연산자 사용 가능
- B-Tree는 항상 정렬된 상태를 유지하기 때문에 조회 속도는 빠르지만 삽입과 수정, 제거 작업은 느리다.
> - B-Tree는 정렬된 트리이므로 탐색이 $O(logN)$의 시간 복잡도를 갖는다.
  
**Hash 인덱스**
- 동등 비교 검색에는 최적화돼 있지만 범위를 검색하거나 정렬된 결과를 가져오지는 못한다.
- DBMS에서 해시 인덱스는 메모리 기반의 테이블에 주로 구현되어 있으며 디스크 기반의 데용량 테이블로용으로는 거의 사용되지 않는다.
- 정렬할 필요가 없으니 삽입/삭제가 빠를 수 있다.

</br>


## #6
### 파이썬에서 메모리는 어떻게 관리되나요?
파이썬에서 메모리 관리는 자동으로 이루어집니다. 파이썬은 고수준의 인터프리터 언어로서, 메모리 할당과 해제를 인터프리터가 메모리 관리를 자동으로 처리합니다.   
파이썬 인터프리터는 CPython이라는 구현체를 기반으로 동작하는데, CPython은 힙 메모리 관리를 수행합니다. 힙은 동적으로 할당된 객체들을 저장하는 메모리 영역으로, 가비지 컬렉션이 이 힙 메모리를 관리합니다. 가비지 컬렉션은 프로그램이 동적으로 할당한 메모리 중에서 더 이상 사용하지 않는 객체들을 자동으로 감지하고 해제하는 기능입니다. 이를 통해 개발자는 메모리 할당 및 해제에 대한 명시적인 관리를 신경 쓰지 않고도 프로그램을 작성할 수 있습니다.  
하지만, 대용량의 데이터 처리나 특정한 상황에서 메모리 사용을 최적화해야 할 경우, 리스트 컴프리헨션(List Comprehension), 제너레이터(Generator) 등을 활용하여 메모리 사용량을 줄일 수 있는 방법이 있습니다.

</br>

## #7
### 힙(heap)이 동적할당을 구현하는데 사용되는 이유가 무엇인가요?
힙을 사용하면 프로그램은 실행 중에 필요한 만큼의 메모리를 동적으로 할당할 수 있습니다. 정적으로 메모리를 할당하는 경우에는 프로그램 실행 중에 메모리 요구 사항이 변경될 수 있으므로 제한적일 수 있습니다. 힙을 사용하면 필요한 메모리 양을 동적으로 조정할 수 있으므로, 프로그램의 유연성과 확장성을 향상시킬 수 있습니다.  
또한 힙을 사용하면 동적인 데이터 구조를 효율적으로 지원할 수 있습니다. 예를 들어, 힙을 사용하여 가장 우선순위가 높은 요소를 추출할 수 있는 우선순위 큐(priority queue)를 구현할 수 있습니다. 이를 통해 필요한 메모리를 할당하는 성능을 향상시킬 수 있습니다.

</br>

## #8
### Garbage Collector(GC)가 무엇인가요?
**Garbage Collector(GC)**는 프로그래밍 언어나 런타임 환경에서 사용되는 메모리 관리 기법 중 하나입니다. Garbage Collector는 동적으로 할당된 메모리 영역 중에서 더 이상 사용되지 않는 객체들을 감지하고 해제하는 역할을 합니다.  
이러한 가비지 컬렉터는 **참조 카운트(reference count) 방식**과 **세대(generation) 기반 방식**이 있습니다.  
참조 카운트(reference count) 방식은 객체가 참조되는 횟수를 추적하여, 해당 객체가 더 이상 참조되지 않을 때 메모리를 해제합니다. 하지만, 객체가 자기 자신을 가르키거나 서로를 참조하는 순환 참조 같은 상황에서는 참조 카운팅만으로는 메모리 누수가 발생할 수 있습니다.   
세대(generation) 기반 방식은 객체를 세대로 분류하고, 가장 빈번한 가비지 컬렉션을 수행하는 0세대부터 시작합니다. 가비지 컬렉션 주기마다 객체의 세대가 증가하며, 높은 세대로 갈수록 가비지 컬렉션 주기가 증가합니다. 이는 오래된 객체는 참조되지 않는 경우가 많아 자주 가비지 수집을 수행하지 않아도 되기 때문입니다. 이를 통해 시스템의 전체적인 성능을 향상시키고 가비지 컬렉션에 소요되는 시간을 최소화할 수 있습니다.  
따라서 파이썬의 GC는 참조 카운트와 세대 기반 가비지 수집을 조합하여 객체의 수명을 관리하고 메모리를 최적화하는 전체적인 메모리 관리 메커니즘을 제공합니다.

</br>

## #9
### JSON과 Dictionary의 차이는 무엇인가요?
JSON(JavaScript Object Notation)은 텍스트 기반의 데이터 교환 형식이며, 딕셔너리는 파이썬의 내장 자료구조로 메모리에 직접 구성됩니다. JSON은 주로 데이터 교환을 위해 사용되고, 딕셔너리는 파이썬 프로그램에서 데이터 구조화 및 처리에 사용됩니다. json의 KEY는 항상 문자열이여야 하지만 dictionary의 KEY는 특정 데이터 타입에 구애 안받는다는 차이점도 있습니다. 파이썬에서는 json 모듈을 사용하여 JSON 데이터를 처리하고 딕셔너리와의 상호 변환을 수행할 수 있습니다.


</br>

# 인성

## #10
### 상사가 본인을 싫어한다면 어떻게 대처하실건가요?


## #11
### 리더의 역할은 무엇이라고 생각하나요?


## #12
### 회사 기술 스택에 맞추어 단기간 내에 언어와 프레임워크를 학습해야 할 때, 어떻게 공부하고 해결할 것인가요?


## #13
### 개발 프로세스에서 어떤게 제일 재미있었나?


## #14
### 상사와의 갈등을 어떻게 해결하시나요?(이미 나왔던 질문이지만 다시 답변 정리해보기 위함)


---

## 추가 조사
- zero centered와 gradient vanishing의 관계
- 해시 테이블
- 파이썬에서의 heap, stack (동적, 정적?)
> [메모리 구조와 메모리 할당방식 이해](https://pearlluck.tistory.com/758)
