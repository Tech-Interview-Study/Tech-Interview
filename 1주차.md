# 📄Table of Contents

# 기술
## Statistics/Math
- [“likelihood”와 “probability”의 차이는 무엇일까요?](#1)
- [중심극한정리는 왜 유용한걸까요?](#2)
- [아웃라이어의 판단하는 기준은 무엇인가요?](#3)
- [모집단과 표본의 차이는 무엇인가요?](#4)

## Deep Learning
- [TensorFlow, PyTorch 특징과 차이가 뭘까요?](#5)
- [ReLU로 어떻게 곡선 함수를 근사하나요?](#6)
- [Data Normalization은 무엇이고 왜 필요한가요?](#7)
- [활성화 함수가 왜 필요한가요?](#8)
- [Gradient Descent에 대해서 중학생이 이해할 수 있게 쉽게 설명해주세요](#9)

## OS
- [프로세스와 스레드의 차이(Process vs Thread)를 알려주세요](#10)
- [멀티 프로세스와 멀티 스레드를 사용하는 이유를 각각 설명해주세요](#11)
- [동기와 비동기의 차이는 무엇인가요?](#12)

## Data Structure
- [배열(array)와 연결리스트(linked list)의 각각의 특징과 장단점을 설명해주세요](#13)

## Computer Science
- [0.1 + 1.1 = 1.2 가 false인 이유를 설명해주세요](#14)
- [Python은 어떤 특징을 가진 언어인가요?](#15)

</br>

# 인성
- [보통 어떤 식으로 자료를 찾아보거나 공부하나요?](#16)
- [본인은 인싸인가요, 아싸인가요?](#17)
- [회사에서 본인에게 하기 싫은 일이 주어졌을 때 어떻게 하실건가요?](#18)
- [만약 이 회사에 떨어진다면 어떤 점이 부족해서 떨어졌다고 생각하나요?](#19)
- [우리회사 외 다른 회사 어디 어디에 지원했습니까?](#20)
- [희망 부서에 배치되지 않아도 괜찮으신가요?](#21)
---

## #1
### “likelihood”와 “probability”의 차이는 무엇일까요?

Probability는 어떤 trial에서 특정 sample이 나올 가능성을 말합니다. 즉, **시행 전 모든 경우의 수의 가능성은 정해져있고**, 그 총합은 1입니다.  
Likelihood는 **trial을 충분히 수행한 후 그 sample을 토대로 경우의 수의 가능성을 도출**하는 것입니다. 아무리 충분히 수행해도 어디까지나 추론inference이기 때문에 가능성의 합이 1이 되지 않을 수 있습니다.

> 확률은 어떤 시행에서 특정 결과가 나올 가능성을 말하며 총합은 1이다. 반면에 가능도는 실재가 바탕이 되어야 하고 어떤 시행을 충분히 수행한 뒤 그 결과를 토대로 겨우의 수의 가능성을 도출하는 것이다. 어디까지나 추론이기 때문에 가능성의 합이 1이 되지 않을 수도 있다.

> 확률(Probability)은 관측값 또는 관측 구간이 **주어진 확률분포** 안에서 얼마나 나타날 수 있는가에 대한 값입니다. 즉, **특정 사건이 일어날 가능성**을 수치화한 것입니다.
반면, 가능도(Likelihood)은 어떤 특정한 값을 관측할 때, 이 관측치가 어떠한 확률분포에서 나왔는가에 관한 값입니다. 즉, 특정 모델이 특정 데이터 세트에 적합한지 측정하는 척도라고 할 수 있습니다.

<br/>

## #2
### 중심극한정리는 왜 유용한걸까요?


**중심극한정리**란 모딥단이 정규분포를 따르지 않는 표본이더라도, **표본들의 수가 30개 이상이면 근사적으로 정규분포를 따른다는 이론**입니다.  
중심극한정리가 유용한 이유는 **모집단의 형태에 관계없이 모분산을 모르는 경우에도,** 표본의 수 n이 30 이상인 경우 **표본 평균의 분포가 정규분포를 따르기 가정**할 수 있기 때문입니다.


<br/>

## #3
### 아웃라이어의 판단하는 기준은 무엇인가요?

아웃라이어를 판단하는 기준은 여러 가지가 있을 수 있습니다.

통계학적으로는 임계값을 설정하고, Z-score이 이 값보다 크다면 이상치로 판단하는 방법과, IQR(Inter Quantile Range) 기법으로 데이터를 오름차순으로 정렬했을 때, **IQR는 75%의 지점 – 25%의 지점**인데, 이 “**75%의 지점 + IQR * 1.5**”의 이상이거나 “**25%의 지점 - IQR * 1.5**”의 이하인 데이터들을 이상치라고 판단하는 방법이 있습니다.  
또는 **도메인 지식을 이용**하여, 데이터가 수집된 분야의 전문적인 지식을 바탕으로 아웃라이어를 판단하거나, **EDA**를 통해 데이터에서 동떨어진 극단값을 판별할 수 있습니다.

<br/>

## #4
### 모집단과 표본의 차이는 무엇인가요?

모집단은 통계적 관찰의 대상이 되는 **집단 전체**를 말합니다. 표본은 모집단 중 **관측된 부분집합**을 말합니다.

<br/>

## #5
### TensorFlow, PyTorch 특징과 차이가 뭘까요?

Tensorflow는 단일 데이터 흐름으로, **그래프를 만들고 그래프 코드를 성능에 맞게 최적화한 다음 모델을 학습하는 define-and-run** 방식이기 때문에 더 쉽게 다른 언어나 모듈에 적용이 가능합니다.  
PyTorch는 **각 반복 단계에서 즉석으로 그래프를 재생성하는 define-by-run** 방식이라 모델 그래프를 만들 때 고정 상태가 아니므로 데이터에 따라 조절이 가능한 유연성을 갖고 있습니다.

> Tensorflow는 **Define and Run** 방식으로 코드를 직접 돌리는 환경인 세션을 만들고, placeholder를 선언하고 이것으로 계산 그래프를 생성한 후에(Define), 코드를 실행하는 시점에 데이터를 넣어 실행하는(Run) 방식입니다. 이는 모델 구조가 미리 정의되어 있기 때문에, 모델 배포가 쉽다는 장점이 있지만, 모델 구조를 변경하려면 새로운 모델을 정의해야 하기 때문에 유연성이 떨어진다는 단점이 있습니다.  
반면, PyTorch는 **Define by Run** 방식으로 계산 그래프의 선언과 동시에 데이터를 집어넣고 세션도 필요없이 돌리면 되기때문에 코드가 간결하고, 더 유연하게 수정하거나 실험할 수 있다는 장점이 있습니다. 그렇지만, 입력 데이터마다 새로운 계산 그래프를 정의하여 사용한다는 단점이 있습니다.

> TensorFlow에서는 Grappler라는 기본 그래프 최적화 시스템이 있습니다. Grappler는 그래프 모드 (tf.function 내)에서 최적화를 적용하여 그래프 단순화 및 함수 본문 인라인과 같은 기타 고급 최적화를 통해 TensorFlow 계산 성능을 향상하여 절차 간 최적화를 가능하게 합니다

<br/>

## #6
### ReLU로 어떻게 곡선 함수를 근사하나요?

ReLU는 **선형(y=x)과 비선형(y=0)의 결합**이기 때문에 ReLU가 반복해 적용되면 선형부분의 결합으로 곡선 함수를 표현할 수 있습니다. ReLU를 여러 개 결합하면, **특정 지점에서 특정 각도만큼 선형 함수를 구부릴 수 있습니다**. 이 성질을 이용하여 곡선 함수 뿐만 아니라 모든 함수에 근사를 할 수 있게 됩니다.


<br/>

## #7
### Data Normalization은 무엇이고 왜 필요한가요?

**Feature들의 분포(scale)을 조절하여 균일하게** 만드는 방법입니다. 즉, 개별 피처의 크기를 모두 똑같은 단위로 변경하는 것입니다.

정규화를 하는 이유는 피쳐들간의 스케일이 심하게 차이가 나는 경우, 값이 큰 피처가 더 중요하게 여겨질 수 있기 때문입니다. 데이터 정규화를 하게 되면 **학습속도가 개선되며, 오버피팅을 억제**할 수 있다는 장점을 얻을 수 있습니다.

이러한 정규화하는 방법으로는 대표적으로 **최소-최대 정규화(min-max norm)와  Z-점수 정규화**가 있습니다.

<br/>

## #8
### 활성화 함수가 왜 필요한가요?

Activation function은 **선형 함수를 비선형함수로** 만들어 표현력을 더 키워주는 함수입니다. Activation function이 없을 경우 layer를 깊게 쌓아도 선형함수기 때문에 의미가 없습니다. Activation function을 이용해 **모델의 복잡도를 높이고** 복잡한 비선형적인 문제를 해결할 수 있게 만듭니다.

<br/>

## #9
### Gradient Descent에 대해서 중학생이 이해할 수 있게 쉽게 설명해주세요.

Gradient Descent는 **함수의 최솟값을 찾기 위해 기울기(경사도)를 이용**하여 함수를 내려가는 것입니다. 이때, 경사도의 반대 방향으로 내려가면서 최솟값에 점점 가까워질 수 있습니다.

딥러닝에서 Gradient Descent는 모델의 가중치(weight)를 업데이트하는 데에 사용됩니다. 모델의 손실(loss)을 최소화하기 위해, Gradient Descent를 사용하여 모델의 가중치를 업데이트하면서 최적의 모델을 학습할 수 있습니다.


<br/>

## #10
### 프로세스와 스레드의 차이(Process vs Thread)를 알려주세요.

프로세스는 프로그램을 실행해 운영체제로부터 자원을 할당받은 **작업의 단위**이고, 스레드는 프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위**입니다. 스레드는 프로세스 내 여러개 생길 수 있으며, **자원 공유가 가능**합니다.

> 프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위로 **메모리에 올라와 실행되고 있는 프로그램의 인스턴스**를 의미합니다. 프로세스는 각각 독립된 메모리 영역(**Code, Data, Stack, Heap**의 구조)을 할당받습니다.  
스레드는 프로세스가 할당받은 자원을 이용하는 **실행의 단위**로 프로세스와는 다른 **더 작은 실행 단위 개념**입니다. 스레드는 프로세스의 코드에 정의된 절차에 따라 실행되는 특정한 수행 경로입니다. 이러한 스레드는 컴퓨터의 중앙 처리 장치(CPU)의 서로 다른 코어에서 프로그램의 여러 부분을 동시에 실행할 수 있기 때문에 병렬 처리를 위해 사용될 수 있습니다.

<br/>

## #11
### 멀티 프로세스와 멀티 스레드를 사용하는 이유를 각각 설명해주세요.

멀티 프로세스는 안정성이 높고 병렬 처리에 특화되어 있으며, 멀티 스레드는 빠른 속도와 경제성을 보유하고 있습니다.

> 멀티 프로세스는 **안정성이 높아** 하나의 프로세스가 잘못돼도 다른 프로세스는 작동하지만, **context switching** 비용이 발생합니다.  
멀티 스레드는 시스템 자원 소모 감소, 처리비용 감소, 스레드간 **자원공유** 등의 장점이 있지만 디버깅이 어렵고, **동기화 이슈발생**, 하나의 스레드의 오류로 전체 프로세스에 문제가 생길 수 있다는 단점이 있습니다.

> **멀티 프로세스는** 하나의 응용프로그램을 **여러 개의 프로세스에서 동시에 실행하여 다중 작업(multi-tasking)을 지원**하는 방법입니다. 각 프로세스는 별도의 메모리 공간을 할당받으므로 안정성이 높고, 하나의 프로세스에 문제가 생겨도 다른 프로세스는 정상적으로 동작한다는 장점이 있습니다.  
**멀티 스레드는** 하나의 응용프로그램을 **하나의 프로세스 안에서 여러 개의 스레드를 동시에 실행하여 다중 작업을 지원**하는 방법입니다. 스레드 간 메모리를 공유하므로 자원을 효율적으로 관리할 수 있지만, 동시에 메모리에 접근하는 경우 데이터 불일치 문제가 발생할 수 있습니다.   
멀티 프로세스와 멀티 스레드 모두 여러 작업을 동시에 처리하여 성능을 향상시킬 수 있습니다.

> 멀티 프로세스는 두 개 이상 다수의 프로세서가 협력적으로 하나 이상의 작업을 동시에 처리하는 것으로 각 프로세스 간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야 할 경우 사용한다. 독립된 구조로 안전성이 높은 장점을 가지고 있지만 작업량이 많을 수록 오버헤드가 발생하여 성능 저하가 발생할 수 있다는 단점을 가지고 있다.  
멀티 스레드는 하나의 프로세스를 여러 스레드로 자원을 공유하며 작업을 나누어 수행하는 것이다. 시스템 자원 소무를 감소하고 자원을 효율적으로 관리할 수 있지만, 병목현상, 데드락 등 자원을 공유하기에 동기화 문제가 발생할 수 있다. 또한 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받는다.

<br/>

## #12
### 동기와 비동기의 차이는 무엇인가요?

동기는 **제어권의 반환과 결과값**이 전달하게 되는 시간이 일치하게 되는 것이고,
비동기는 제어권의 반환과 결과값의 전달 시간이 일치하지 않을 수 있는 것입니다.  
> 동기는 데이터의 요청과 결과가 한 자리에서 동시에 일어나기 때문에 **설계가 매우 간단하고 직관적**이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 한다는 단점이 있습니다.  
비동기는 요청에 따른 결과가 반환되는 시간 동안 **다른 작업을 수행할 수 있지만, 동기식보다 설계가 복잡**합니다.

<br/>

## #13
### 배열(array)와 연결리스트(linked list)의 각각의 특징과 장단점을 설명해주세요.

Array는 **연속된 메모리 주소**를 할당받게 되는데 이때 index를 갖게됩니다. Array는 index를 가지고 임의 접근이 가능하고 접근과 탐색에 용이하다는 장점을 가지고 있지만 크기를 미리 정해놓았기 때문에 해당 배열 크기 이상의 데이터를 저장할 수 없다는 단점이 있습니다.  
Linked List는 동적 자료구조로 크기를 정할 필요가 없고 배열처럼 연속된 메모리 주소를 할당받지 않습니다. 대신 노드(Node) 안에 데이터가 있고, 다음 데이터를 가리키는 주소를 가지고 있습니다. Linked List는 **크기의 제한이 없으므로 데이터 추가, 삭제가 자유롭다**는 장점이 있지만, 메모리 주소를 할당받지 않았기 때문에 임의로 접근하는 것은 불가능하여 데이터를 탐색할 때 순차적으로 접근해야 한다는 단점이 있습니다.

> **배열은** 메모리상에서 연속적으로 저장되어 있기 때문에, index를 통한 접근이 용이합니다. 배열의 크기는 처음 생성할 때 정하며 이후에는 변경할 수 없다는 특징이 있습니다.  
**연결 리스트**는 여러 개의 노드들이 순차적으로 연결된 형태를 갖는 자료구조이며, 첫번째 노드를 헤드(Head), 마지막 노드를 테일(Tail) 이라고 하며, 이때 각 노드는 데이터와 다음 노드를 가리키는 포인터로 이루어져있습니다. 배열과는 다르게 메모리를 연속적으로 사용하지 않기 때문에 접근은 불리할 수 있으나, **크기의 제한이 없어, 데이터 추가, 삭제가 자유롭다는 특징이 있습니다.**

<br/>

## #14
### 0.1 + 1.1 = 1.2 가 false인 이유를 설명해주세요.

컴퓨터에서 실수를 저장할 때 정수부분과 실수부분을 나누어 앞과 뒤의 칸에 **2진법으로** 저장을 하게 되는데, 0.1단위 소숫점을 2진법으로 표현하면 무한히 길어지게 되어 **일정부분을 자르고 저장**을 하게 됩니다. 이때 잘린 만큼의 오차가 있기때문에 0.1+1.1=1.2 가 False 값으로 나오게 됩니다.  
파이썬에서는 `decimal` 모듈을 사용해 해결할 수 있습니다.

<br/>

## #15
### Python은 어떤 특징을 가진 언어인가요?

파이썬은 **interpreter language**라 실행 전에 컴파일할 필요가 없습니다. **동적 타이핑**이기 때문에 실행시간에 자료형을 검사하므로 자료형을 명시할 필요가 없습니다.

>  파이썬은 인터프리터 언어이므로, 실행하기 전에 컴파일을 할 필요가 없습니다. 그러나 컴파일러가 코드를 기계어로 번역해서 실행가능 파일을 만드는 것에 비해, 인터프리터는 코드를 한줄씩 실행할 때마다 번역해서 실행하기 때문에 다른 컴파일 언어에 비해 다소 느리다는 특징이 있습니다.  
또한, 파이썬은 클래스와 구성 및 상속을 함께 정의할 수 있는 **객체** **지향** **프로그래밍(OOP)**입니다**.**


---
# 인성

## #16
### 보통 어떤 식으로 자료를 찾아보거나 공부하나요?

- 기술 관련된 자료는 stack overflow에 검색해보거나 다큐멘트를 찾아봅니다. 최근에는 bing검색으로 정보를 찾고 구글에 레퍼런스를 검색하는 방식을 이용하고 있습니다.


- 저는 보통 키워드를 통해 구글링을 하며 블로그나 공식 문서를 통해 공부합니다. 이렇게 글로 보다보면 이해가 되지 않을 때가 있는데 이때 주로 유튜브를 통해 설명을 듣곤합니다.


- 요즘에는 빙 챗이나 openai 챗 gpt에 물어보면서 공부를 하는 경우가 많습니다. 빙 챗의 경우에는 답변에 참고된 사이트를 알려주며 답변하기 때문에 인터넷 검색 결과를 요약해 보는 느낌이고, 오픈AI의 챗 gpt는 유저가 원하는 방향의 답변을 이끌어내기에 더 최적화되었다고 느꼈습니다.

    만약, 해당 개념에 대해 좀 더 깊은 이해가 필요할 것 같다고 생각되면, 유튜브나 강의를 참고하여 공부합니다.

<br/>

## #17
### 본인은 인싸인가요, 아싸인가요?

- 저는 부분 인싸라고 생각합니다. 너무 많은 사람들이 모인 곳에서는 조용해지는 반면, 취미나 프로젝트 등 같은 목적으로 모인 사람들 사이에서는 활발해지고 의견 교류도 적극적으로 하는 성격이 되기 때문입니다.


- 인간관계의 넓이를 기준으로 본다면 저는 인싸 중에 아싸인 것 같습니다. 저는 좁고 깊은 인간관계를 추구하기 때문에 저는 아싸이지만, 모든 사람과 원만한 관계를 유지하기 때문에 인싸 중에 아싸라고 생각합니다.


- 저는 아싸라고 생각합니다. 좋은 인간관계를 갖는 것도 좋지만, 친구들과 만나는 것보다는 계획한 일을 하는 것이 개인적으로 만족감이 더 큰 것 같습니다. 그러나, 이렇게 커리어적으로 노력하다보면 제가 하고자 하는 일과 관련된 사람들과 점점 더 연을 맺게될 일이 생길 것이라고 생각합니다.

<br/>

## #18
### 회사에서 본인에게 하기 싫은 일이 주어졌을 때 어떻게 하실건가요?

- 어떠한 일이 주어졌다는 것은 기업에서 그 일을 필요로 하기 때문이라고 생각합니다. 또한 그 일에 필요한 능력은 회사가 제게 바라고 있는 능력이라고 생각합니다. 우선 제가 왜 그 일을 싫어하는지 생각해본 후, 그 일을 마치고 성장해있을 제 자신을 상상하며 수행해내도록 하겠습니다.


- 먼저 직무에 관련된 일인지 파악할 것입니다. 만약 직무와 관련 있는 일이면, 가장 먼저 일을 끝낸 후 끝냈다는 성취감을 원동력으로 다른 일을 처리할 것입니다. 반면에 직무와 관련되지 않은 일이라면 현재 하고 있는 일에 비해 시간이 더 소요된다고 생각합니다. 그래서 저는 직무에 관련된 일을 빠르게 처리한 후 하기 싫은 일에 대해 자세히 파악한 후 일을 처리할 것입니다.

- 직무 관련일이라면, 크게 하기 싫은 일은 따로 없을 것 같습니다. 그러나 하기 싫은 일이 주어졌다고 생각하여도 회사에 필요한 업무인 경우 책임감이 들기 때문에, 크게 신경 쓰이지 않고 일을 처리할 것 같습니다.

<br/>

## #19
### 만약 이 회사에 떨어진다면 어떤 점이 부족해서 떨어졌다고 생각하나요?

- 제가 갖고있는 열정과 재능을 면접에서 다 보여주지 못했기 때문이라고 생각합니다. 지금까지 해왔던 것처럼 프로젝트를 진행하며 실무경험과 전공지식을 쌓아 다시 도전하겠습니다.  
-> 지원 직무에 필요한 능력이 뭔지 분석하고, 그게 부족하다고 구체적으로 말해주면 좋을 것 같음


- 제가 가지고 있는 열정에 비해 짧은 시간안에 전달하지 못했기 때문이라고 생각합니다. 떨어지게 된다면 저의 표현력을 키워 저를 보완한 후 다시 도전해 꼭 합격하겠습니다.


- 셀프 피드백 + 명확하게 답변하지 못한 부분 언급 + 기회가 된다면 다시 설명
- 셀프 피드백 + 부족한 점을 인정 + 향후 보완 계획

<br/>

## #20
### 우리회사 외 다른 회사 어디 어디에 지원했습니까?

- 솔직하게, 왜 해당 회사의 특정 직군을 지원했는지에 대한 동기와 함께 답변. + 해당 회사가 어떤 차별점이 있어서 붙고 싶은지?


- 현재 면접보는 곳이랑 비슷한 직무 2~3개 + 해당 회사랑 현재 지원한 곳이랑 어떤 차별점이 있어 이 회사에서 가장 일하고 싶다는 점을 어필하면 좋을듯

<br/>

## #21
### 희망 부서에 배치되지 않아도 괜찮으신가요?

- 저는 사람의 삶을 편하게 해주는 개발자가 되기 위해 이 직무에 지원했습니다. 이 직무에 대한 역량을 키우기 위해 지식과 경험을 쌓았습니다. 그래서 가장 희망하는 것은 xx직무이고, 이를 맡아 좋은 성과를 내고 싶습니다.  
하지만 회사라는 조직 구성상 제가 하고 싶은 일만 할 수 없다는 것 또한 충분히 이해하고 있습니다. 회사와 경영진 입장에서도 다양한 사정을 고려해, 다른 직무를 제안하는 이유가 있을 것이라고 생각합니다. 조직의 구성원이라면 응당 이를 이해하기 위해 노력해야 한다고 생각합니다. 직무 변경이 필요하다면 긍정적으로 수용할 수 있도록 고민하고, 그 직무에서도 제 역량을 최대한 발휘해 좋은 성과를 낼 수 있는 방법을 찾겠습니다.   
당장은 A직무가 아니라도 다른 업무들을 수행하다보면 경험과 노하우가 쌓일 것이고, 이는 추후 A직무를 맡아 수행하는데도 도움이 될 것이라 생각합니다. 또 새로운 일을 해보면 미처 발견하지 못했던 역량과 흥미를 발견할 수도 있을 것이고요. 다른 업무 경험을 통해 다양하고 폭넓은 업무 스킬을 익힐 수 있는 좋은 기회가 될 수 있다고 생각합니다. 지속적인 자기개발을 통해 제가 희망하고 있는 A직무를 맡을 기회가 왔을 때 더 좋은 성과를 낼 수 있도록 노력하겠습니다." 


- 저는 주니어 시절에 많은 것을 경험하고 싶습니다. 타 부서 업무를 열심히 공부하고 개발 역량을 늘린 후 기회가 된다면 제가 원하는 부서로 이동할 수 있도록 할 것입니다.

- AI, 빅데이터 직군과 관련된 부서라면 크게 개의치 않을 것 같습니다. 개인적인 목표는 데이터 사이언티스트이기 때문에, 관련된 다양한 경험들이 도움이 될 것이라고 생각합니다. 따라서 다른 부서이더라도 새로운 기술들을 배우며, 성장해 나가도록 할 것 입니다.



